type vec3 = { f64 x, f64 y, f64 z }
type point = vec3
type color = vec3
type ray = { point origin, vec3 direction }
type record = {
    u1 hit,
    point p,
    vec3 normal,
    f64 t,
    u1 front_face,
}
type sphere = {
    point center,
    f64 radius,
}
type camera = {
    f64 focal_length,
    f64 vp_height,
    f64 vp_width,
    point center,
    vec3 vp_u,
    vec3 vp_v,
    vec3 pd_u,
    vec3 pd_v,
    point vp_ul,
    point p00_loc,
}

type _util = {
    [(f64, f64, f64) => f64] clamp,
    [(f64) => f64] gamma,
}
type _ppm = {
    [(i32, i32, i32) => i32] print_header,
    [(color) => i32] print_color,
}
type _vec3 = {
    [() => vec3] empty,
    [(f64) => vec3] scalar,
    [(f64, f64, f64) => vec3] vec3,
    [(vec3) => vec3] neg,
    [(vec3, vec3) => vec3] add,
    [(vec3, vec3) => vec3] sub,
    [(vec3, f64) => vec3] mul,
    [(vec3, f64) => vec3] div,
    [(vec3) => f64] length_squared,
    [(vec3) => f64] length,
    [(vec3) => vec3] normalize,
    [(vec3, vec3) => f64] dot,
    [(vec3, vec3) => vec3] cross,
}
type _ray = {
    [(ray, f64) => point] at,
}
type _sphere = {
    [(sphere, ray, f64, f64) => record] hit
}

printf([i8], ...) => i32
sqrt(f64) => f64

util() => _util = {
    $(f64 x, f64 min, f64 max) => f64 = x < min ? min : x > max ? max : x,
    $(f64 c) => f64 = c #c < 0 ? 0 : sqrt(c),
}

ppm() => _ppm = {
    $(i32 width, i32 height, i32 max) => i32 = printf("P3\n%d %d\n%d\n", width, height, max),
    $(color c) => i32 = (
        r = util().gamma(c.x), g = util().gamma(c.y), b = util().gamma(c.z),
        ir = (util().clamp(r, 0.0, 0.999) * 256) as i32,
        ig = (util().clamp(g, 0.0, 0.999) * 256) as i32,
        ib = (util().clamp(b, 0.0, 0.999) * 256) as i32,
        printf("%d %d %d\n", ir, ig, ib),
    )
}

vec3() => _vec3 = {
    $() => vec3 = { 0.0, 0.0, 0.0 },
    $(f64 t) => vec3 = { t, t, t },
    $(f64 x, f64 y, f64 z) => vec3 = { x, y, z },
    $(vec3 v) => vec3 = { -v.x, -v.y, -v.z },
    $(vec3 u, vec3 v) => vec3 = { u.x + v.x, u.y + v.y, u.z + v.z },
    $(vec3 u, vec3 v) => vec3 = { u.x - v.x, u.y - v.y, u.z - v.z },
    $(vec3 v, f64 t) => vec3 = { v.x * t, v.y * t, v.z * t },
    $(vec3 v, f64 t) => vec3 = vec3().mul(v, 1 / t),
    $(vec3 v) => f64 = v.x * v.x + v.y * v.y + v.z * v.z,
    $(vec3 v) => f64 = sqrt(vec3().length_squared(v)),
    $(vec3 v) => vec3 = vec3().div(v, vec3().length(v)),
    $(vec3 u, vec3 v) => f64 = u.x * v.x + u.y * v.y + u.z * v.z,
    $(vec3 u, vec3 v) => vec3 = {
        u.y * v.z - u.z * v.y,
        u.z * v.x - u.x * v.z,
        u.x * v.y - u.y * v.x,
    },
}

ray() => _ray = {
    $(ray r, f64 t) => point = vec3().add(r.origin, vec3().mul(r.direction, t)),
}

sphere() => _sphere = {
    $(sphere s, ray r, f64 t_min, f64 t_max) => record = (
        oc = vec3().sub(s.center, r.origin),
        a = vec3().length_squared(r.direction),
        b = vec3().dot(r.direction, oc),
        c = vec3().length_squared(oc) - s.radius * s.radius,
        discriminant = b * b - a * c,
        discriminant < 0 ? { 0 } => record : (
            sqrtd = sqrt(discriminant),
            t1 = (b - sqrtd) / a,
            t2 = (b + sqrtd) / a,
            v1 = t1 <= t_min || t_max <= t1,
            v2 = t2 <= t_min || t_max <= t2,
            v1 && v2 ? { 0 } => record : (
                t = v1 ? t2 : t1,
                p = ray().at(r, t),
                on = vec3().div(vec3().sub(p, s.center), s.radius),
                f = vec3().dot(r.direction, on) < 0,
                n = f ? on : vec3().neg(on),
                { !0, p, n, t, f }
            )
        )
    )
}

mix_color(color a, color b, f64 t) => color = vec3().add(vec3().mul(a, 1 - t), vec3().mul(b, t))

ray_color(ray r) => color = (
    rec = sphere().hit({ { 0.0, 0.0, -1.0 }, 0.5 }, r, 0.001, 1000.0),
    (rec.hit) ? (
        vec3().mul({ rec.normal.x + 1, rec.normal.y + 1, rec.normal.z + 1 }, 0.5)
    ) : (
        a = r.direction.y * 0.5 + 0.5,
        mix_color({ 1.0, 1.0, 1.0 }, { 0.5, 0.7, 1.0 }, a)
    )
)

pixel_color(camera cam, i32 x, i32 y, i32 width, i32 height) => color = (
    pc = vec3().add(cam.p00_loc, vec3().add(vec3().mul(cam.pd_u, x), vec3().mul(cam.pd_v, y))),
    o = cam.center,
    d = vec3().normalize(vec3().sub(pc, cam.center)),
    ray_color({ o, d })
)

for_column(camera cam, i32 x, i32 y, i32 width, i32 height) => i32
 = x < width
 ? (
    c = pixel_color(cam, x, y, width, height),
    ppm().print_color(c),
    for_column(cam, x + 1, y, width, height)
 ) : 0

for_row(camera cam, i32 x, i32 y, i32 width, i32 height) => i32
 = y < height
 ? (
    for_column(cam, x, y, width, height),
    for_row(cam, x, y + 1, width, height)
 ) : 0

main(i32 argc, [[i8]] argv) => i32 = (
    width = 1920, height = 1080,
    ppm().print_header(width, height, 255),

    focal_length = 1.0,

    vp_height = 2.0,
    vp_width = vp_height * width / height,

    center = vec3().empty(),

    vp_u = { vp_width, 0.0, 0.0 },
    vp_v = { 0.0, -vp_height, 0.0 },

    pd_u = vec3().div(vp_u, width),
    pd_v = vec3().div(vp_v, height),

    vp_ul = vec3().sub(vec3().sub(vec3().sub(center, { 0.0, 0.0, focal_length }), vec3().div(vp_u, 2)), vec3().div(vp_v, 2)),
    p00_loc = vec3().add(vp_ul, vec3().mul(vec3().add(pd_u, pd_v), 0.5)),

    cam = { focal_length, vp_height, vp_width, center, vp_u, vp_v, pd_u, pd_v, vp_ul, p00_loc, },

    for_row(cam, 0, 0, width, height),

    0
)
